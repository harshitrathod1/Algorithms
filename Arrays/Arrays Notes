A) Kadane's Algorithm

1. Greedy Algorithm to find maximum sum subarray.
2. Algorithm :->
    a. Take two variables
      -> max_end_here = 0
      -> max_so_far = Integer.MIN_VALUE
      -> start = 0,end = 0;
    
    b. Traverse over the array i[0,N-1] :-
      -> max_end_here = max_end_here + a[i]
      -> if(max_end_here > max_so_far) max_so_far = max_end_here
      -> if(max_end_here < 0) max_end_here = 0;
   
    c. return max_so_far

B)  Pascal's Triangle and Solving nCr 

               n * (n-1) * (n-2) ... r times
1. nCr  ->    -----------------------------    (IMP)
               r * (r-1) * (r-2) * ... 1
   Time Complexity of solving nCr -> {O(N) because r in worst case could be N-1 which will have time complexity of O(N-1)}
   Calculating Pascals triangle of M elements -> O(M*N) not optimal..
   When anyone gives row = x and col = y (assuming 0 based indexing) -> xCy -> O(N)
                                         (assuming 1 based indexing) -> (x-1)C(y) -> O(N)
2. Finding kth row of pascals triangle ->
    
    a.) nCr * f = nC(r+1)
          f = (n-r)/(r+1)
    b.) nC0 = 1, nCn = 1
    c.) pascal(i,j) -> pascal(i-1,j-1) + pascal(i-1,j) = subList.add(pre.get(j-1)) + subList.add(pre.get(j))

C)  Next Permutation

    a.) Find value from right of array such that a[i] > a[i-1], breakIndex = i - 1;
    b.) Find value i.e. justGreater than breakIndex and rightMost from (breakIndex to N)
    c.) Swap breakIndex and justGreater
    d.) reverse the array from breakIndex + 1 onwards to N
    
D)  Dutch National Flag Algorithm

    a.) Given a pivot and array, this algorithm partitions array into three segments
        [less than pivot elements] + pivot + [greater than pivot]
        It does guarntee that these paritions are sorted.
    b.) Algorithm -> to sort array of three colors or consisting of 0,1,2 only,here pivot = 1
       -> low,mid = 0, high = N - 1;
       -> if(arr[mid] == 0) swap(mid,low) low++; mid++;
       -> if(arr[mid] == 1) mid++;
       -> if(arr[mid] == 2) swap(mid,high) high--;
       
 E) Transpose of a matrix :- is nothing but rotating the matrix around the diagonal.
    b.) M * N matrix gets converted to N * M matrix
    c.) Allocate extra new space N * M to store the transpose of matrix
    d.) Diagonal elements remain intact and all other generic elements such as mat[i][j] goes to new location new_mat[j][i].
    [1,2,3]      [1,4,7]  
    [4,5,6]  ->  [2,5,8]
    [7,8,9]      [3,6,9]
    
    Follow up ROTATE MATRIX BY 90 -> Calculate the transpose and calculate reverse for every row.
    

